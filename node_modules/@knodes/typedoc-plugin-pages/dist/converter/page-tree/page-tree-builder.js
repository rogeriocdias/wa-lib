"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PageTreeBuilder = void 0;
const assert_1 = __importDefault(require("assert"));
const typedoc_1 = require("typedoc");
const typedoc_pluginutils_1 = require("@knodes/typedoc-pluginutils");
const utils_1 = require("./utils");
const reflections_1 = require("../../models/reflections");
const isModuleRoot = (pageNode) => 'moduleRoot' in pageNode && !!pageNode.moduleRoot;
class PageTreeBuilder {
    constructor(plugin) {
        this.plugin = plugin;
        this._logger = this.plugin.logger.makeChildLogger(PageTreeBuilder.name);
    }
    /**
     * Convert pages specified in the plugin options to reflections.
     *
     * @param project - The project reflection.
     * @param options - The plugin options.
     * @returns the nodes tree.
     */
    buildPagesTree(project, options) {
        var _a;
        const rootMenu = new reflections_1.MenuReflection('ROOT', project, undefined, '');
        if (!options.pages || options.pages.length === 0) {
            return rootMenu;
        }
        else {
            if (options.pages.some(p => p.moduleRoot)) {
                rootMenu.childrenNodes = this._mapNodesToReflectionsTree(options.pages, project, { inputContainer: options.source, output: options.output });
            }
            else {
                const projectRoot = new reflections_1.MenuReflection(project.name, project, project, (_a = project.url) !== null && _a !== void 0 ? _a : '');
                projectRoot.childrenNodes = this._mapNodesToReflectionsTree(options.pages, projectRoot, { inputContainer: options.source, output: options.output });
                rootMenu.childrenNodes = projectRoot.childrenNodes.length > 0 ? [projectRoot] : [];
            }
            return rootMenu;
        }
    }
    /**
     * Get the module with the given {@link name}.
     *
     * @param reflection - The reflection to get the project from.
     * @param name - The name of the module to search.
     * @returns the module declaration reflection, or `undefined`.
     */
    _getModule(reflection, name) {
        if (name === reflection.project.name) {
            return reflection.project;
        }
        const modules = (0, typedoc_pluginutils_1.getWorkspaces)(reflection.project).slice(1);
        const modulesWithName = modules.filter(m => m.name === name);
        (0, assert_1.default)(modulesWithName.length === 1);
        return modulesWithName[0];
    }
    /**
     * Map multiple raw page node objects to node reflections.
     *
     * @param nodes - The nodes.
     * @param parent - The parent of this node (project, module or node).
     * @param io - The children base input/output paths
     * @returns the node reflections.
     */
    _mapNodesToReflectionsTree(nodes, parent, io) {
        return nodes
            .map(n => this._mapNodeToReflection(n, parent, io))
            .flat(1);
    }
    /**
     * Map a single raw page node object to node reflections.
     *
     * @param node - The node.
     * @param parent - The parent of this node (project, module or node).
     * @param io - The children base input/output paths
     * @returns the node reflections.
     */
    _mapNodeToReflection(node, parent, io) {
        var _a;
        const childrenIO = isModuleRoot(node) ? Object.assign({}, io) : Object.assign(Object.assign({}, io), { input: (0, utils_1.join)(io.input, (0, utils_1.getDir)(node, 'source')), output: (0, utils_1.join)(io.output, (0, utils_1.getDir)(node, 'output')) });
        if (node.name === 'VIRTUAL') {
            return node.children ?
                this._mapNodesToReflectionsTree(node.children, parent, childrenIO) :
                [];
        }
        const nodeReflection = this._getNodeReflection(node, parent, io);
        if (!(nodeReflection.module instanceof typedoc_1.ProjectReflection) && nodeReflection.isModuleAppendix) {
            // If the node is attached to a new module, skip changes in the input tree (stay at root of `pages` in module)
            childrenIO.input = io.input;
            // Output is now like `pkg-a/pages/...`
            childrenIO.output = `${nodeReflection.name.replace(/[^a-z0-9]/gi, '_')}/${(_a = io.output) !== null && _a !== void 0 ? _a : ''}`;
        }
        const children = node.children ?
            this._mapNodesToReflectionsTree(node.children, nodeReflection, childrenIO) :
            [];
        // Strip empty menu items
        if (nodeReflection instanceof reflections_1.MenuReflection && children.length === 0) {
            this._logger.warn(`Stripping menu item ${(0, utils_1.getNodePath)(node, parent)} because it has no children.`);
            return [];
        }
        nodeReflection.childrenNodes = children;
        return [nodeReflection];
    }
    /**
     * Infer the parent & module for the given node.
     *
     * @param node - The node to get parent & modules for.
     * @param parent - The default parent.
     * @returns an object containing the final module & parent for the node.
     */
    _getNodeParent(node, parent) {
        const module = isModuleRoot(node) ?
            typedoc_pluginutils_1.miscUtils.catchWrap(() => this._getModule(parent, node.name), `Invalid pages configuration: could not find a workspace named "${node.name}"`) :
            parent instanceof reflections_1.ANodeReflection ? parent.module : parent.project;
        return { module, parent: parent instanceof reflections_1.ANodeReflection ? parent : module };
    }
    /**
     * Generate a node reflection.
     *
     * @param node - The node.
     * @param parent - The parent of this node (project, module or node).
     * @param io - This node input/output paths.
     * @returns the node reflection.
     */
    _getNodeReflection(node, parent, io) {
        const { module, parent: actualParent } = this._getNodeParent(node, parent);
        if (node.source) {
            const nodePath = (0, utils_1.join)(io.input, node.source);
            const sourceFilePath = typedoc_pluginutils_1.miscUtils.catchWrap(() => { var _a; return (0, typedoc_pluginutils_1.resolveNamedPath)(module, (_a = io.inputContainer) !== null && _a !== void 0 ? _a : undefined, nodePath); }, err => {
                const path = err instanceof typedoc_pluginutils_1.ResolveError ? `./${this.plugin.relativeToRoot(err.triedPath)}` : nodePath;
                return new Error(`Could not locate page for ${(0, utils_1.getNodePath)(node, actualParent)}. Searched for "${path}"`, { cause: err });
            });
            const page = typedoc_pluginutils_1.miscUtils.catchWrap(() => new reflections_1.PageReflection(node.name, module, actualParent, sourceFilePath, nodePath, (0, typedoc_1.normalizePath)((0, utils_1.join)(io.output, (0, utils_1.getNodeUrl)(node)))), `Could not generate a page reflection for ${(0, utils_1.getNodePath)(node, actualParent)}`);
            page.comment = this.plugin.application.converter.parseRawComment(new typedoc_1.MinimalSourceFile(page.content, page.sourceFilePath));
            return page;
        }
        return new reflections_1.MenuReflection(node.name, module, actualParent, (0, typedoc_1.normalizePath)((0, utils_1.join)(io.output, (0, utils_1.getNodeUrl)(Object.assign({ output: 'index.html' }, node)))));
    }
}
exports.PageTreeBuilder = PageTreeBuilder;
//# sourceMappingURL=page-tree-builder.js.map