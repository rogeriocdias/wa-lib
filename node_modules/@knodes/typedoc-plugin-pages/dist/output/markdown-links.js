"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindReplaceMarkdown = exports.MarkdownPagesLinks = void 0;
const assert_1 = __importDefault(require("assert"));
const lodash_1 = require("lodash");
const typedoc_pluginutils_1 = require("@knodes/typedoc-pluginutils");
const page_tree_1 = require("../converter/page-tree");
const reflections_1 = require("../models/reflections");
const options_1 = require("../options");
const EXTRACT_PAGE_LINK_REGEX = /([^}\s]+)(?:\s+([^}]+?))?\s*/g;
class MarkdownPagesLinks {
    constructor(plugin, _themeMethods, event) {
        this.plugin = plugin;
        this._themeMethods = _themeMethods;
        this._currentPageMemo = typedoc_pluginutils_1.CurrentPageMemo.for(this);
        this._markdownReplacer = new typedoc_pluginutils_1.MarkdownReplacer(this);
        this._logger = this.plugin.logger.makeChildLogger(MarkdownPagesLinks.name);
        const nodeReflections = event.project.getReflectionsByKind(reflections_1.PagesPluginReflectionKind.PAGE);
        (0, assert_1.default)(nodeReflections.every((v) => v instanceof reflections_1.PageReflection));
        this._nodesReflections = nodeReflections;
        this._markdownReplacer.registerMarkdownTag('@page', EXTRACT_PAGE_LINK_REGEX, this._replacePageLink.bind(this), {
            excludedMatches: this.plugin.pluginOptions.getValue().excludeMarkdownTags,
        });
        this._currentPageMemo.initialize();
    }
    /**
     * Transform the parsed page link.
     *
     * @param capture - The captured infos.
     * @param sourceHint - The best guess to the source of the match,
     * @returns the replaced content.
     */
    _replacePageLink({ captures }, sourceHint) {
        const [page, label] = captures;
        try {
            const targetPage = this._resolvePageLink(page);
            if (targetPage) {
                this._logger.verbose(() => `Created a link from ${sourceHint()} to ${(0, page_tree_1.getNodePath)(targetPage)}`);
                return this._themeMethods.renderPageLink({ label: label !== null && label !== void 0 ? label : undefined, page: targetPage });
            }
        }
        catch (err) {
            this._handleResolveError(err, page, sourceHint);
        }
    }
    /**
     * Handle a page resolution error according to user options.
     *
     * @param err - The error thrown.
     * @param page - The page in the inline tag.
     * @param sourceHint - The best guess to the source of the match,
     */
    _handleResolveError(err, page, sourceHint) {
        var _a;
        const message = `Could not resolve page "${page}" from reflection ${this._currentPageMemo.currentReflection.name}: ${(_a = err.message) !== null && _a !== void 0 ? _a : err}`;
        switch (this.plugin.pluginOptions.getValue().invalidPageLinkHandling) {
            case options_1.EInvalidPageLinkHandling.FAIL: {
                throw new Error(message, { cause: err });
            }
            case options_1.EInvalidPageLinkHandling.LOG_ERROR:
                {
                    this._logger.error(`In ${sourceHint()}: ${message}`);
                }
                break;
            case options_1.EInvalidPageLinkHandling.LOG_WARN:
                {
                    this._logger.warn(`In ${sourceHint()}: ${message}`);
                }
                break;
            case options_1.EInvalidPageLinkHandling.NONE:
                {
                    this._logger.verbose(`In ${sourceHint()}: ${message}`);
                }
                break;
            default: {
                assert_1.default.fail(`Invalid \`invalidPageLinkHandling\` option value ${this.plugin.pluginOptions.getValue().invalidPageLinkHandling}`);
            }
        }
    }
    /**
     * Find the actual page that matches the given page alias.
     *
     * @param pageAlias - The page alias, usually in the form of a {@link NamedPath}.
     * @returns the resolved page.
     */
    _resolvePageLink(pageAlias) {
        var _a;
        (0, assert_1.default)(this._nodesReflections);
        (0, assert_1.default)((0, lodash_1.isString)(pageAlias));
        const resolvedFile = (0, typedoc_pluginutils_1.resolveNamedPath)(this._currentPageMemo.currentReflection, (_a = this.plugin.pluginOptions.getValue().source) !== null && _a !== void 0 ? _a : undefined, pageAlias);
        const page = this._nodesReflections.find(m => m.sourceFilePath === resolvedFile);
        (0, assert_1.default)(page, new Error('Page not found'));
        return page;
    }
}
exports.MarkdownPagesLinks = MarkdownPagesLinks;
const bindReplaceMarkdown = (plugin, themeMethods, event) => new MarkdownPagesLinks(plugin, themeMethods, event);
exports.bindReplaceMarkdown = bindReplaceMarkdown;
//# sourceMappingURL=markdown-links.js.map