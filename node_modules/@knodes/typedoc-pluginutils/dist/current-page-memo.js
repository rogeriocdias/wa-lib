"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrentPageMemo = void 0;
const assert_1 = __importDefault(require("assert"));
const lodash_1 = require("lodash");
const typedoc_1 = require("typedoc");
const base_plugin_1 = require("./base-plugin");
class CurrentPageMemo {
    get initialized() {
        return this._initialized;
    }
    /**
     * Get the instance for the given plugin.
     *
     * @param applicationAccessor - The application accessor to get memo for.
     * @returns the plugin page memo
     */
    static for(applicationAccessor) {
        var _a;
        const application = (0, base_plugin_1.getApplication)(applicationAccessor);
        const e = (_a = this._applications.get(application)) !== null && _a !== void 0 ? _a : new CurrentPageMemo(application);
        this._applications.set(application, e);
        return e;
    }
    constructor(application) {
        this.application = application;
        this._initialized = false;
    }
    /**
     * Start watching for pages event.
     */
    initialize() {
        if (this._initialized) {
            return;
        }
        this._initialized = true;
        this.application.renderer.on(typedoc_1.PageEvent.BEGIN, (e) => this._currentPage = e);
        this.application.renderer.on(typedoc_1.PageEvent.END, () => this._currentPage = undefined);
    }
    /**
     * Set the current page as being the {@link pageOrModel} while running the {@link callback}. The current page is restored afterwards no matter what.
     *
     * @param pageOrModel - The page to set.
     * @param callback - The function to execute.
     * @returns the {@link callback} return value.
     */
    fakeWrapPage(pageOrModel, callback) {
        let newPage;
        if (pageOrModel instanceof typedoc_1.PageEvent) {
            newPage = pageOrModel;
        }
        else {
            newPage = new typedoc_1.PageEvent(typedoc_1.PageEvent.BEGIN);
            newPage.model = pageOrModel;
        }
        const bck = this._currentPage;
        this._currentPage = newPage;
        try {
            return callback();
        }
        finally {
            this._currentPage = bck;
        }
    }
    get currentPage() {
        (0, assert_1.default)(this._currentPage);
        (0, assert_1.default)(this._currentPage.model instanceof typedoc_1.Reflection);
        return this._currentPage;
    }
    get currentReflection() {
        return this.currentPage.model;
    }
    get hasCurrent() {
        return !(0, lodash_1.isNil)(this._currentPage);
    }
}
CurrentPageMemo._applications = new WeakMap();
exports.CurrentPageMemo = CurrentPageMemo;
//# sourceMappingURL=current-page-memo.js.map