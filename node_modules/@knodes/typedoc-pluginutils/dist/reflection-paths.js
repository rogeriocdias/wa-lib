"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveNamedPath = exports.ResolveError = exports.getReflectionModule = exports.getReflectionParentMatching = exports.isModule = exports.getWorkspaces = exports.findModuleRoot = void 0;
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const lodash_1 = require("lodash");
const typedoc_1 = require("typedoc");
const path_1 = require("./utils/path");
const isRootFile = (dir, file) => !!(file.match(/^readme.md$/i) || file.match(/^package.json$/));
exports.findModuleRoot = (0, lodash_1.memoize)((reflection, rootMatcher = isRootFile) => {
    var _a, _b, _c, _d, _e, _f;
    const projectReflection = reflection.project;
    const projectRootFile = (_c = (_b = (_a = projectReflection.sources) === null || _a === void 0 ? void 0 : _a.find(src => {
        const { dir, base } = (0, path_1.parse)(src.fullFileName);
        return rootMatcher(dir, base);
    })) === null || _b === void 0 ? void 0 : _b.fullFileName) !== null && _c !== void 0 ? _c : assert_1.default.fail('Can\'t get the project root');
    const projectRootDir = (0, typedoc_1.normalizePath)((0, path_1.dirname)(projectRootFile));
    if (reflection === projectReflection) {
        return projectRootDir;
    }
    for (const source of (_d = reflection.sources) !== null && _d !== void 0 ? _d : []) {
        const root = _findModuleRoot((0, typedoc_1.normalizePath)((0, path_1.dirname)(source.fullFileName)), projectRootDir, rootMatcher);
        if (root) {
            return root;
        }
    }
    return (0, path_1.dirname)((_f = (_e = reflection.sources) === null || _e === void 0 ? void 0 : _e[0].fullFileName) !== null && _f !== void 0 ? _f : assert_1.default.fail(`Reflection ${reflection.getFriendlyFullName()} has no known source`));
});
const _findModuleRoot = (0, lodash_1.memoize)((moduleDir, projectRoot, rootMatcher) => {
    if (moduleDir === projectRoot) {
        return null;
    }
    const files = (0, fs_1.readdirSync)(moduleDir);
    if (files.some(f => rootMatcher(moduleDir, f))) {
        return moduleDir;
    }
    return _findModuleRoot((0, typedoc_1.normalizePath)((0, path_1.dirname)(moduleDir)), projectRoot, rootMatcher);
});
const getWorkspaces = (project) => {
    const modules = project.getReflectionsByKind(typedoc_1.ReflectionKind.Module);
    (0, assert_1.default)(modules.every((m) => m instanceof typedoc_1.DeclarationReflection));
    return [
        project,
        ...modules,
    ];
};
exports.getWorkspaces = getWorkspaces;
const isModule = (reflection) => reflection instanceof typedoc_1.DeclarationReflection && reflection.kindOf(typedoc_1.ReflectionKind.Module);
exports.isModule = isModule;
const getReflectionParentMatching = (reflection, filter) => {
    let reflectionCursor = reflection;
    while (reflectionCursor) {
        if (filter(reflectionCursor)) {
            return reflectionCursor;
        }
        reflectionCursor = reflectionCursor.parent;
    }
    return reflectionCursor;
};
exports.getReflectionParentMatching = getReflectionParentMatching;
const getReflectionModule = (reflection) => { var _a; return (_a = (0, exports.getReflectionParentMatching)(reflection, exports.isModule)) !== null && _a !== void 0 ? _a : reflection.project; };
exports.getReflectionModule = getReflectionModule;
class ResolveError extends Error {
    constructor(triedPath, options) {
        super(`Could not resolve ${triedPath}`, options);
        this.triedPath = triedPath;
    }
}
exports.ResolveError = ResolveError;
/**
 * Resolve a named path. See {@page resolving-paths.md} for details.
 *
 * @param args - The reflection to resolve from, an optional container folder, and the target path specifier.
 * @returns the resolved path.
 */
const resolveNamedPath = (...args) => {
    var _a, _b;
    const [currentReflection, containerFolder, path] = args.length === 3 ? args : [args[0], undefined, args[1]];
    let containerFolderMut = containerFolder;
    let pathMut = (0, typedoc_1.normalizePath)(path);
    let reflectionRoots = (0, exports.findModuleRoot)((0, exports.getReflectionModule)(currentReflection));
    if (pathMut.startsWith('~~:')) {
        pathMut = pathMut.slice(3);
        reflectionRoots = (0, exports.findModuleRoot)(currentReflection.project);
    }
    else if (pathMut.match(/^~.+?:/)) {
        const workspaces = (0, exports.getWorkspaces)(currentReflection.project).slice(1).filter(w => pathMut.startsWith(`~${w.name}:`));
        const workspace = workspaces[0];
        if (!workspace) {
            throw new Error(`Could not get a module corresponding to the path ${path.slice(1)}`);
        }
        else if (workspaces.length > 1) {
            throw new Error(`Ambiguous reference for path ${pathMut}. Matched ${workspaces.map(w => w.name).join(', ')}`);
        }
        pathMut = pathMut.slice(workspace.name.length + 2);
        reflectionRoots = (0, exports.findModuleRoot)(workspace);
    }
    else if (pathMut.match(/^~:/)) {
        pathMut = pathMut.slice(2);
        reflectionRoots = (0, exports.findModuleRoot)((0, exports.getReflectionModule)(currentReflection));
    }
    else if (pathMut.match(/^\.{1,2}\//)) {
        containerFolderMut = undefined;
        reflectionRoots = (0, path_1.dirname)((_b = (_a = currentReflection.sources) === null || _a === void 0 ? void 0 : _a[0].fullFileName) !== null && _b !== void 0 ? _b : assert_1.default.fail());
    }
    (0, assert_1.default)(reflectionRoots);
    const resolved = (0, typedoc_1.normalizePath)((0, path_1.resolve)(reflectionRoots, containerFolderMut !== null && containerFolderMut !== void 0 ? containerFolderMut : '.', pathMut));
    if ((0, fs_1.existsSync)(resolved)) {
        return resolved;
    }
    throw new ResolveError(resolved);
};
exports.resolveNamedPath = resolveNamedPath;
//# sourceMappingURL=reflection-paths.js.map