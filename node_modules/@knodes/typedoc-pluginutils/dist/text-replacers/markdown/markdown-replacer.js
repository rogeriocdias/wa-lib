"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkdownReplacer = void 0;
const assert_1 = __importDefault(require("assert"));
const lodash_1 = require("lodash");
const typedoc_1 = require("typedoc");
const source_map_container_1 = require("./source-map-container");
const base_plugin_1 = require("../../base-plugin");
const current_page_memo_1 = require("../../current-page-memo");
const utils_1 = require("../../utils");
const text_1 = require("../../utils/text");
const spitArgs = (...args) => {
    const indexIdx = args.findIndex(lodash_1.isNumber);
    (0, assert_1.default)(indexIdx > 0);
    return {
        fullMatch: args[0],
        captures: args.slice(1, indexIdx),
        index: args[indexIdx],
        source: args[indexIdx + 1],
    };
};
const mergeFlags = (...flags) => (0, lodash_1.uniq)(flags.join('').split('')).join('');
const buildMarkdownRegExp = (tagName, paramsRegExp) => paramsRegExp ?
    new RegExp(`${(0, lodash_1.escapeRegExp)(tagName)}(?:\\s+${paramsRegExp.source})?`, mergeFlags(paramsRegExp.flags, 'g')) :
    new RegExp(`${(0, lodash_1.escapeRegExp)(tagName)}`, 'g');
class MarkdownReplacer {
    /**
     * Get the list of source map containers for the given event.
     *
     * @param event - The event to get source maps for.
     * @returns the source map list.
     */
    static _getEventMapContainer(event) {
        var _a;
        const container = (_a = this._mapContainers.get(event)) !== null && _a !== void 0 ? _a : new source_map_container_1.SourceMapContainer();
        MarkdownReplacer._mapContainers.set(event, container);
        return container;
    }
    constructor(pluginAccessor) {
        this.plugin = (0, base_plugin_1.getPlugin)(pluginAccessor);
        this._logger = this.plugin.logger.makeChildLogger('MarkdownReplacer');
        this._currentPageMemo = current_page_memo_1.CurrentPageMemo.for(this);
    }
    /**
     * Register an inline tag (eg. `{@tag ....}`) to replace in markdown with optional params regex and execute a callback to replace it.
     *
     * @param tagName - The name of the tag to match.
     * @param paramsRegExp - An optional regex to capture params.
     * @param callback - The callback to execute to replace the match.
     * @param options - Extra options.
     */
    registerMarkdownTag(tagName, paramsRegExp, callback, options = {}) {
        const mdRegexBase = buildMarkdownRegExp(tagName, paramsRegExp);
        const tagRegex = new RegExp(`\\{${mdRegexBase.source}\\s*?\\}`, mdRegexBase.flags);
        this._currentPageMemo.initialize();
        const { excludedMatches, priority } = Object.assign({ excludedMatches: [], priority: 100 }, options);
        this.plugin.application.renderer.on(typedoc_1.MarkdownEvent.PARSE, this._processMarkdown.bind(this, tagRegex, ({ fullMatch, captures, event }, sourceHint) => {
            const newFullMatch = fullMatch.slice(2).slice(0, -1);
            return callback({ fullMatch: newFullMatch, captures, event }, sourceHint);
        }, tagName, excludedMatches), undefined, priority);
    }
    /**
     * Match every strings for {@link regex} & replace them with the return value of the {@link callback}. This method mutates the {@link event}.
     *
     * @param regex - The regex to match.
     * @param callback - The callback to execute with fullMatch, captures, & a source hint.
     * @param label - The replacer name.
     * @param excludeMatches - A list of matches to skip.
     * @param event - The event to modify.
     */
    _processMarkdown(regex, callback, label, excludeMatches, event) {
        const originalText = event.parsedText;
        const mapLayer = MarkdownReplacer._getEventMapContainer(event).addLayer(label, originalText);
        const sourceFile = this._currentPageMemo.hasCurrent ? utils_1.reflectionSourceUtils.getReflectionSourceFileName(this._currentPageMemo.currentReflection) : undefined;
        event.parsedText = originalText.replace(regex, (...args) => {
            const { captures, fullMatch, index } = spitArgs(...args);
            if (excludeMatches === null || excludeMatches === void 0 ? void 0 : excludeMatches.includes(fullMatch)) {
                return fullMatch;
            }
            const getSourceHint = mapLayer.sourceHint.bind(mapLayer, sourceFile, index);
            const replacement = utils_1.miscUtils.catchWrap(() => (0, text_1.jsxToString)(callback({ fullMatch, captures, event }, getSourceHint)), err => `In ${getSourceHint()}: ${err.message}`);
            if ((0, lodash_1.isNil)(replacement)) {
                return fullMatch;
            }
            mapLayer.addEdition(index, fullMatch, replacement);
            return replacement;
        });
    }
}
MarkdownReplacer._mapContainers = new WeakMap();
exports.MarkdownReplacer = MarkdownReplacer;
//# sourceMappingURL=markdown-replacer.js.map