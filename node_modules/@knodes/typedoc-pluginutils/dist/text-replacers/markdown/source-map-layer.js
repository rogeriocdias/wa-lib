"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceMapLayer = void 0;
const utils_1 = require("../../utils");
class SourceMapLayer {
    get resultingText() {
        return this._resultingText;
    }
    constructor(label, originalText, _parentLayer) {
        this.label = label;
        this.originalText = originalText;
        this._parentLayer = _parentLayer;
        this.editions = [];
        this._resultingText = this.originalText;
    }
    /**
     * Add a new edition to this layer.
     *
     * @param from - The position where the edit starts.
     * @param source - The original content.
     * @param replacement - The replacement content.
     */
    addEdition(from, source, replacement) {
        const edition = { from, replacement, source };
        const deltaPos = this._remapSelfEditPos(from).delta;
        this.editions.push(edition);
        this._resultingText = this._resultingText.slice(0, from + deltaPos) + replacement + this._resultingText.slice(from + source.length + deltaPos);
    }
    /**
     * Return a string describing the position of the given index in the source file.
     *
     * @param sourceFile - The source file name.
     * @param index - The char index.
     * @returns a string like `"hello.ts:42:84" (in expansion of @tag1 ⇒ @tag2)"
     */
    sourceHint(sourceFile, index) {
        if (!sourceFile) {
            return 'UNKNOWN SOURCE';
        }
        const { line, column, layers: expansions } = this._getSourceMap(index, false);
        const posStr = line && column ? `:${line}:${column}` : '';
        const expansionContext = ` (in expansion of ${expansions.map(e => e.label).join(' ⇒ ')})`;
        return `"${sourceFile}${posStr}"${expansionContext}`;
    }
    /**
     * Map the given {@link pos} in the 1st layer's content.
     *
     * @param pos - The character index.
     * @param mapSelf - A flag indicating if this layer's editions should be mapped.
     * @returns the source map.
     */
    _getSourceMap(pos, mapSelf = true) {
        var _a, _b;
        const { offsetedPos, isExpansionApplied } = mapSelf ? this._remapSelfEditPos(pos) : { offsetedPos: pos, isExpansionApplied: true };
        const editionContext = (_b = (_a = this._parentLayer) === null || _a === void 0 ? void 0 : _a._getSourceMap(offsetedPos)) !== null && _b !== void 0 ? _b : Object.assign(Object.assign({}, utils_1.textUtils.getCoordinates(this.originalText, offsetedPos)), { pos: offsetedPos, layers: [] });
        if (isExpansionApplied) {
            editionContext.layers = [...editionContext.layers, this];
        }
        return editionContext;
    }
    /**
     * Remap the given position in this layer's editions.
     *
     * @param pos - The character position.
     * @returns the mapped position.
     */
    _remapSelfEditPos(pos) {
        const remap = this.editions.reduce((acc, edit) => {
            const isAfterEdit = edit.from <= acc.offsetedPos;
            if (!isAfterEdit) {
                return acc;
            }
            const _isExpansionApplied = edit.from + edit.replacement.length > acc.offsetedPos;
            const isOffsettedPosInEdit = edit.from <= acc.offsetedPos && edit.from + edit.replacement.length >= acc.offsetedPos;
            const newAcc = {
                offsetedPos: isOffsettedPosInEdit ?
                    edit.from :
                    acc.offsetedPos - (edit.replacement.length - edit.source.length),
                isExpansionApplied: _isExpansionApplied || acc.isExpansionApplied,
            };
            return newAcc;
        }, { offsetedPos: pos, isExpansionApplied: false });
        return Object.assign(Object.assign({}, remap), { delta: remap.offsetedPos - pos });
    }
}
exports.SourceMapLayer = SourceMapLayer;
//# sourceMappingURL=source-map-layer.js.map