"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReflectionCommentReplacer = void 0;
const typedoc_1 = require("typedoc");
const base_plugin_1 = require("../../base-plugin");
const events_extra_1 = require("../../events-extra");
const filterDisplayParts = (tagName) => (commentPart) => commentPart.kind === 'inline-tag' && commentPart.tag === tagName;
class ReflectionCommentReplacer {
    constructor(pluginAccessor) {
        this.plugin = (0, base_plugin_1.getPlugin)(pluginAccessor);
    }
    /**
     * Register an inline tag (`{@tag ...}`) and execute an optional function on found instances.
     *
     * @param tagName - The name of the tag to match.
     * @param callback - An optional callback to execute on found tags.
     * @param priority - The priority to run the callback if provided.
     */
    registerInlineTag(tagName, callback, priority) {
        events_extra_1.EventsExtra.for(this.plugin.application)
            .beforeOptionsFreeze(() => {
            this.plugin.application.options.getValue('inlineTags').push(tagName);
        });
        if (callback) {
            this.plugin.application.converter.on(typedoc_1.Converter.EVENT_RESOLVE, (context, reflection) => {
                const comment = reflection.comment;
                if (!comment) {
                    return;
                }
                const filter = filterDisplayParts(tagName);
                comment.summary.forEach((t, i) => {
                    if (filter(t)) {
                        callback({ comment, kind: 'summary', tag: t, context, reflection, replace: v => comment.summary[i] = v });
                    }
                });
                comment.blockTags.forEach(b => b.content.forEach((t, i) => {
                    if (filter(t)) {
                        callback({ comment, kind: 'blockComment', tag: t, block: b, context, reflection, replace: v => b.content[i] = v });
                    }
                }));
            }, null, priority);
        }
    }
    /**
     * Register a block tag (`\n@tag ...\n`) and execute an optional function on found instances.
     *
     * @param tagName - The name of the tag to match.
     * @param callback - An optional callback to execute on found tags.
     * @param priority - The priority to run the callback if provided.
     */
    registerBlockTag(tagName, callback, priority) {
        events_extra_1.EventsExtra.for(this.plugin.application)
            .beforeOptionsFreeze(() => {
            this.plugin.application.options.getValue('blockTags').push(tagName);
        });
        if (callback) {
            this.plugin.application.converter.on(typedoc_1.Converter.EVENT_RESOLVE, (context, reflection) => {
                const comment = reflection.comment;
                if (!comment) {
                    return;
                }
                comment.blockTags.forEach((b, i) => {
                    if (b.tag === tagName) {
                        callback({ comment, kind: 'block', block: b, context, reflection, replace: v => comment.blockTags[i] = v });
                    }
                });
            }, null, priority);
        }
    }
}
exports.ReflectionCommentReplacer = ReflectionCommentReplacer;
//# sourceMappingURL=reflection-comment-replacer.js.map